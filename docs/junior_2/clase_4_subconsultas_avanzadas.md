# Clase 4: Subconsultas Avanzadas - L√≥gica Compleja

## üìö Descripci√≥n de la Clase
En esta clase profundizar√°s en las subconsultas avanzadas de SQL, aprendiendo t√©cnicas m√°s sofisticadas como subconsultas correlacionadas, operadores EXISTS, IN, ANY, ALL, y subconsultas con m√∫ltiples valores. Dominar√°s estas herramientas para resolver problemas complejos de an√°lisis de datos.

## üéØ Objetivos de la Clase
Al finalizar esta clase, ser√°s capaz de:
- Usar subconsultas correlacionadas para an√°lisis complejos
- Aplicar el operador EXISTS para verificar existencia
- Implementar operadores IN, ANY, ALL para comparaciones m√∫ltiples
- Crear subconsultas con m√∫ltiples valores y columnas
- Optimizar subconsultas avanzadas para mejor rendimiento
- Resolver problemas complejos usando combinaciones de t√©cnicas

## ‚è±Ô∏è Duraci√≥n Estimada
**4-5 horas** (dependiendo de tu ritmo de aprendizaje)

---

## üìñ Contenido Te√≥rico

### Subconsultas Correlacionadas

Las **subconsultas correlacionadas** son subconsultas que hacen referencia a columnas de la consulta externa. Se ejecutan una vez por cada fila de la consulta externa.

#### Caracter√≠sticas de Subconsultas Correlacionadas:
- **Referencia externa**: Acceden a columnas de la consulta principal
- **Ejecuci√≥n m√∫ltiple**: Se ejecutan para cada fila externa
- **Dependencia**: Su resultado depende del contexto externo
- **Rendimiento**: Pueden ser m√°s lentas que subconsultas independientes

#### Sintaxis de Subconsultas Correlacionadas
```sql
SELECT columnas
FROM tabla1 t1
WHERE condicion (
    SELECT columna
    FROM tabla2 t2
    WHERE t2.columna = t1.columna
);
```

**Explicaci√≥n l√≠nea por l√≠nea:**
- `FROM tabla1 t1`: tabla principal con alias
- `WHERE condicion`: condici√≥n que usa la subconsulta
- `(SELECT columna FROM tabla2 t2 WHERE t2.columna = t1.columna)`: subconsulta correlacionada
- `WHERE t2.columna = t1.columna`: correlaci√≥n entre tablas

### Operador EXISTS

EXISTS verifica si una subconsulta devuelve al menos una fila. Es muy √∫til para verificar existencia de registros relacionados.

#### Sintaxis de EXISTS
```sql
SELECT columnas
FROM tabla1
WHERE EXISTS (
    SELECT 1
    FROM tabla2
    WHERE condicion
);
```

**Explicaci√≥n l√≠nea por l√≠nea:**
- `WHERE EXISTS`: verifica existencia de resultados
- `(SELECT 1 FROM tabla2 WHERE condicion)`: subconsulta de existencia
- `SELECT 1`: no importa qu√© se seleccione, solo la existencia
- Devuelve TRUE si hay al menos una fila, FALSE si no hay ninguna

#### Ventajas de EXISTS:
- **Rendimiento**: Se detiene en la primera coincidencia
- **Legibilidad**: C√≥digo m√°s claro que COUNT() > 0
- **Eficiencia**: No necesita procesar todas las filas

### Operadores IN, ANY, ALL

Estos operadores permiten comparar un valor con m√∫ltiples valores de una subconsulta.

#### Operador IN
```sql
SELECT columnas
FROM tabla1
WHERE columna IN (
    SELECT columna
    FROM tabla2
    WHERE condicion
);
```

**Explicaci√≥n l√≠nea por l√≠nea:**
- `WHERE columna IN`: compara con lista de valores
- `(SELECT columna FROM tabla2 WHERE condicion)`: subconsulta que devuelve m√∫ltiples valores
- Devuelve TRUE si el valor est√° en la lista

#### Operador ANY
```sql
SELECT columnas
FROM tabla1
WHERE columna OPERADOR ANY (
    SELECT columna
    FROM tabla2
    WHERE condicion
);
```

**Explicaci√≥n l√≠nea por l√≠nea:**
- `WHERE columna OPERADOR ANY`: compara con cualquier valor de la lista
- `OPERADOR`: puede ser =, >, <, >=, <=, !=
- Devuelve TRUE si la condici√≥n se cumple para al menos un valor

#### Operador ALL
```sql
SELECT columnas
FROM tabla1
WHERE columna OPERADOR ALL (
    SELECT columna
    FROM tabla2
    WHERE condicion
);
```

**Explicaci√≥n l√≠nea por l√≠nea:**
- `WHERE columna OPERADOR ALL`: compara con todos los valores de la lista
- `OPERADOR`: puede ser =, >, <, >=, <=, !=
- Devuelve TRUE si la condici√≥n se cumple para todos los valores

---

## üíª Ejemplos Pr√°cticos

### Ejemplo 1: Subconsultas Correlacionadas

```sql
-- Consulta 1: Productos con precio superior al promedio de su categor√≠a
SELECT 
    p.nombre AS producto,
    p.precio,
    c.nombre AS categoria,
    (SELECT AVG(precio) FROM productos p2 WHERE p2.categoria_id = p.categoria_id) AS precio_promedio_categoria
FROM productos p
INNER JOIN categorias c ON p.categoria_id = c.id
WHERE p.precio > (
    SELECT AVG(precio)
    FROM productos p2
    WHERE p2.categoria_id = p.categoria_id
);

-- Explicaci√≥n l√≠nea por l√≠nea:
-- WHERE p.precio >: compara precio del producto
-- (SELECT AVG(precio) FROM productos p2 WHERE p2.categoria_id = p.categoria_id): subconsulta correlacionada
-- p2.categoria_id = p.categoria_id: correlaci√≥n por categor√≠a
-- AVG(precio): calcula promedio por categor√≠a
-- Resultado: productos m√°s caros que el promedio de su categor√≠a

-- Consulta 2: Usuarios que han gastado m√°s que el promedio de su grupo de edad
SELECT 
    u.nombre AS usuario,
    u.email,
    SUM(p.total) AS total_gastado,
    (SELECT AVG(total_gastado) FROM (
        SELECT SUM(total) AS total_gastado
        FROM pedidos p2
        INNER JOIN usuarios u2 ON p2.usuario_id = u2.id
        WHERE YEAR(CURDATE()) - YEAR(u2.fecha_nacimiento) BETWEEN 
              YEAR(CURDATE()) - YEAR(u.fecha_nacimiento) - 5 AND 
              YEAR(CURDATE()) - YEAR(u.fecha_nacimiento) + 5
        GROUP BY u2.id
    ) AS gastos_por_edad) AS promedio_grupo_edad
FROM usuarios u
INNER JOIN pedidos p ON u.id = p.usuario_id
GROUP BY u.id, u.nombre, u.email, u.fecha_nacimiento
HAVING SUM(p.total) > (
    SELECT AVG(total_gastado)
    FROM (
        SELECT SUM(total) AS total_gastado
        FROM pedidos p2
        INNER JOIN usuarios u2 ON p2.usuario_id = u2.id
        WHERE YEAR(CURDATE()) - YEAR(u2.fecha_nacimiento) BETWEEN 
              YEAR(CURDATE()) - YEAR(u.fecha_nacimiento) - 5 AND 
              YEAR(CURDATE()) - YEAR(u.fecha_nacimiento) + 5
        GROUP BY u2.id
    ) AS gastos_por_edad
);

-- Explicaci√≥n l√≠nea por l√≠nea:
-- HAVING SUM(p.total) >: filtra despu√©s de agregaci√≥n
-- Subconsulta correlacionada anidada: compara con promedio del grupo de edad
-- YEAR(CURDATE()) - YEAR(u.fecha_nacimiento): calcula edad
-- BETWEEN ... AND ...: define rango de edad (¬±5 a√±os)
-- Resultado: usuarios que gastan m√°s que su grupo de edad

-- Consulta 3: Productos con mejor rendimiento que el promedio de su categor√≠a
SELECT 
    p.nombre AS producto,
    p.precio,
    c.nombre AS categoria,
    (SELECT SUM(dp.cantidad) FROM detalle_pedidos dp WHERE dp.producto_id = p.id) AS total_vendido,
    (SELECT AVG(total_vendido) FROM (
        SELECT SUM(dp2.cantidad) AS total_vendido
        FROM detalle_pedidos dp2
        INNER JOIN productos p2 ON dp2.producto_id = p2.id
        WHERE p2.categoria_id = p.categoria_id
        GROUP BY p2.id
    ) AS ventas_por_categoria) AS promedio_ventas_categoria
FROM productos p
INNER JOIN categorias c ON p.categoria_id = c.id
WHERE (SELECT SUM(dp.cantidad) FROM detalle_pedidos dp WHERE dp.producto_id = p.id) > (
    SELECT AVG(total_vendido)
    FROM (
        SELECT SUM(dp2.cantidad) AS total_vendido
        FROM detalle_pedidos dp2
        INNER JOIN productos p2 ON dp2.producto_id = p2.id
        WHERE p2.categoria_id = p.categoria_id
        GROUP BY p2.id
    ) AS ventas_por_categoria
);

-- Explicaci√≥n l√≠nea por l√≠nea:
-- WHERE (SELECT SUM(dp.cantidad) FROM detalle_pedidos dp WHERE dp.producto_id = p.id) >: compara ventas del producto
-- Subconsulta correlacionada: calcula promedio de ventas por categor√≠a
-- p2.categoria_id = p.categoria_id: correlaci√≥n por categor√≠a
-- Resultado: productos con ventas superiores al promedio de su categor√≠a
```

### Ejemplo 2: Operador EXISTS

```sql
-- Consulta 1: Usuarios que han hecho pedidos
SELECT 
    u.nombre AS usuario,
    u.email,
    u.fecha_registro
FROM usuarios u
WHERE EXISTS (
    SELECT 1
    FROM pedidos p
    WHERE p.usuario_id = u.id
);

-- Explicaci√≥n l√≠nea por l√≠nea:
-- WHERE EXISTS: verifica existencia de pedidos
-- (SELECT 1 FROM pedidos p WHERE p.usuario_id = u.id): subconsulta de existencia
-- SELECT 1: no importa qu√© se seleccione, solo la existencia
-- WHERE p.usuario_id = u.id: condici√≥n de correlaci√≥n
-- Resultado: usuarios que tienen al menos un pedido

-- Consulta 2: Productos que nunca se han vendido
SELECT 
    p.nombre AS producto,
    p.precio,
    c.nombre AS categoria
FROM productos p
INNER JOIN categorias c ON p.categoria_id = c.id
WHERE NOT EXISTS (
    SELECT 1
    FROM detalle_pedidos dp
    WHERE dp.producto_id = p.id
);

-- Explicaci√≥n l√≠nea por l√≠nea:
-- WHERE NOT EXISTS: verifica que NO existan ventas
-- (SELECT 1 FROM detalle_pedidos dp WHERE dp.producto_id = p.id): subconsulta de existencia
-- NOT EXISTS: niega la existencia
-- Resultado: productos que nunca se han vendido

-- Consulta 3: Categor√≠as que tienen productos vendidos
SELECT 
    c.nombre AS categoria,
    c.descripcion
FROM categorias c
WHERE EXISTS (
    SELECT 1
    FROM productos p
    INNER JOIN detalle_pedidos dp ON p.id = dp.producto_id
    WHERE p.categoria_id = c.id
);

-- Explicaci√≥n l√≠nea por l√≠nea:
-- WHERE EXISTS: verifica existencia de productos vendidos
-- Subconsulta: busca productos de la categor√≠a que tengan ventas
-- INNER JOIN detalle_pedidos dp ON p.id = dp.producto_id: une con ventas
-- WHERE p.categoria_id = c.id: correlaci√≥n por categor√≠a
-- Resultado: categor√≠as que tienen al menos un producto vendido
```

### Ejemplo 3: Operadores IN, ANY, ALL

```sql
-- Consulta 1: Productos de categor√≠as populares (m√°s de 3 productos)
SELECT 
    p.nombre AS producto,
    p.precio,
    c.nombre AS categoria
FROM productos p
INNER JOIN categorias c ON p.categoria_id = c.id
WHERE p.categoria_id IN (
    SELECT categoria_id
    FROM productos
    GROUP BY categoria_id
    HAVING COUNT(*) > 3
);

-- Explicaci√≥n l√≠nea por l√≠nea:
-- WHERE p.categoria_id IN: compara con lista de categor√≠as
-- (SELECT categoria_id FROM productos GROUP BY categoria_id HAVING COUNT(*) > 3): subconsulta
-- GROUP BY categoria_id: agrupa por categor√≠a
-- HAVING COUNT(*) > 3: filtra categor√≠as con m√°s de 3 productos
-- Resultado: productos de categor√≠as populares

-- Consulta 2: Productos con precio superior a cualquier producto de ropa
SELECT 
    p.nombre AS producto,
    p.precio,
    c.nombre AS categoria
FROM productos p
INNER JOIN categorias c ON p.categoria_id = c.id
WHERE p.precio > ANY (
    SELECT precio
    FROM productos p2
    INNER JOIN categorias c2 ON p2.categoria_id = c2.id
    WHERE c2.nombre = 'Ropa'
);

-- Explicaci√≥n l√≠nea por l√≠nea:
-- WHERE p.precio > ANY: compara con cualquier precio de ropa
-- (SELECT precio FROM productos p2 INNER JOIN categorias c2 ON p2.categoria_id = c2.id WHERE c2.nombre = 'Ropa'): subconsulta
-- WHERE c2.nombre = 'Ropa': filtra solo productos de ropa
-- > ANY: mayor que cualquier precio de ropa
-- Resultado: productos m√°s caros que el producto de ropa m√°s barato

-- Consulta 3: Productos con precio superior a todos los productos de electr√≥nicos
SELECT 
    p.nombre AS producto,
    p.precio,
    c.nombre AS categoria
FROM productos p
INNER JOIN categorias c ON p.categoria_id = c.id
WHERE p.precio > ALL (
    SELECT precio
    FROM productos p2
    INNER JOIN categorias c2 ON p2.categoria_id = c2.id
    WHERE c2.nombre = 'Electr√≥nicos'
);

-- Explicaci√≥n l√≠nea por l√≠nea:
-- WHERE p.precio > ALL: compara con todos los precios de electr√≥nicos
-- (SELECT precio FROM productos p2 INNER JOIN categorias c2 ON p2.categoria_id = c2.id WHERE c2.nombre = 'Electr√≥nicos'): subconsulta
-- WHERE c2.nombre = 'Electr√≥nicos': filtra solo productos de electr√≥nicos
-- > ALL: mayor que todos los precios de electr√≥nicos
-- Resultado: productos m√°s caros que el producto de electr√≥nicos m√°s caro

-- Consulta 4: Usuarios que han comprado productos de todas las categor√≠as
SELECT 
    u.nombre AS usuario,
    u.email
FROM usuarios u
WHERE NOT EXISTS (
    SELECT 1
    FROM categorias c
    WHERE NOT EXISTS (
        SELECT 1
        FROM pedidos p
        INNER JOIN detalle_pedidos dp ON p.id = dp.pedido_id
        INNER JOIN productos pr ON dp.producto_id = pr.id
        WHERE p.usuario_id = u.id
        AND pr.categoria_id = c.id
    )
);

-- Explicaci√≥n l√≠nea por l√≠nea:
-- WHERE NOT EXISTS: verifica que NO exista categor√≠a sin compra
-- Subconsulta externa: busca categor√≠as
-- WHERE NOT EXISTS: verifica que NO exista compra de esa categor√≠a
-- Subconsulta interna: busca compras del usuario en esa categor√≠a
-- Resultado: usuarios que han comprado de todas las categor√≠as
```

---

## üéØ Ejercicios Pr√°cticos

### Ejercicio 1: Subconsultas Correlacionadas
**Objetivo**: Practicar subconsultas correlacionadas para an√°lisis complejos.

**Instrucciones**:
1. Encontrar productos con precio superior al promedio de su categor√≠a
2. Mostrar usuarios que gastan m√°s que el promedio de su grupo de edad
3. Identificar productos con mejor rendimiento que el promedio de su categor√≠a
4. Crear ranking de productos dentro de cada categor√≠a

**Soluci√≥n paso a paso:**

```sql
-- Consulta 1: Productos con precio superior al promedio de su categor√≠a
SELECT 
    p.nombre AS producto,
    p.precio,
    c.nombre AS categoria,
    ROUND((SELECT AVG(precio) FROM productos p2 WHERE p2.categoria_id = p.categoria_id), 2) AS precio_promedio_categoria
FROM productos p
INNER JOIN categorias c ON p.categoria_id = c.id
WHERE p.precio > (
    SELECT AVG(precio)
    FROM productos p2
    WHERE p2.categoria_id = p.categoria_id
)
ORDER BY c.nombre, p.precio DESC;

-- Explicaci√≥n:
-- WHERE p.precio >: compara precio del producto
-- (SELECT AVG(precio) FROM productos p2 WHERE p2.categoria_id = p.categoria_id): subconsulta correlacionada
-- p2.categoria_id = p.categoria_id: correlaci√≥n por categor√≠a
-- ROUND: redondea el promedio para mostrar
-- ORDER BY: ordena por categor√≠a y precio

-- Consulta 2: Usuarios que gastan m√°s que el promedio de su grupo de edad
SELECT 
    u.nombre AS usuario,
    u.email,
    YEAR(CURDATE()) - YEAR(u.fecha_nacimiento) AS edad,
    SUM(p.total) AS total_gastado,
    ROUND((SELECT AVG(total_gastado) FROM (
        SELECT SUM(total) AS total_gastado
        FROM pedidos p2
        INNER JOIN usuarios u2 ON p2.usuario_id = u2.id
        WHERE YEAR(CURDATE()) - YEAR(u2.fecha_nacimiento) BETWEEN 
              YEAR(CURDATE()) - YEAR(u.fecha_nacimiento) - 5 AND 
              YEAR(CURDATE()) - YEAR(u.fecha_nacimiento) + 5
        GROUP BY u2.id
    ) AS gastos_por_edad), 2) AS promedio_grupo_edad
FROM usuarios u
INNER JOIN pedidos p ON u.id = p.usuario_id
GROUP BY u.id, u.nombre, u.email, u.fecha_nacimiento
HAVING SUM(p.total) > (
    SELECT AVG(total_gastado)
    FROM (
        SELECT SUM(total) AS total_gastado
        FROM pedidos p2
        INNER JOIN usuarios u2 ON p2.usuario_id = u2.id
        WHERE YEAR(CURDATE()) - YEAR(u2.fecha_nacimiento) BETWEEN 
              YEAR(CURDATE()) - YEAR(u.fecha_nacimiento) - 5 AND 
              YEAR(CURDATE()) - YEAR(u.fecha_nacimiento) + 5
        GROUP BY u2.id
    ) AS gastos_por_edad
)
ORDER BY total_gastado DESC;

-- Explicaci√≥n:
-- YEAR(CURDATE()) - YEAR(u.fecha_nacimiento) AS edad: calcula edad
-- HAVING SUM(p.total) >: filtra despu√©s de agregaci√≥n
-- Subconsulta correlacionada: compara con promedio del grupo de edad
-- BETWEEN ... AND ...: define rango de edad (¬±5 a√±os)
-- Resultado: usuarios que gastan m√°s que su grupo de edad

-- Consulta 3: Productos con mejor rendimiento que el promedio de su categor√≠a
SELECT 
    p.nombre AS producto,
    p.precio,
    c.nombre AS categoria,
    COALESCE((SELECT SUM(dp.cantidad) FROM detalle_pedidos dp WHERE dp.producto_id = p.id), 0) AS total_vendido,
    ROUND((SELECT AVG(total_vendido) FROM (
        SELECT COALESCE(SUM(dp2.cantidad), 0) AS total_vendido
        FROM detalle_pedidos dp2
        INNER JOIN productos p2 ON dp2.producto_id = p2.id
        WHERE p2.categoria_id = p.categoria_id
        GROUP BY p2.id
    ) AS ventas_por_categoria), 2) AS promedio_ventas_categoria
FROM productos p
INNER JOIN categorias c ON p.categoria_id = c.id
WHERE COALESCE((SELECT SUM(dp.cantidad) FROM detalle_pedidos dp WHERE dp.producto_id = p.id), 0) > (
    SELECT AVG(total_vendido)
    FROM (
        SELECT COALESCE(SUM(dp2.cantidad), 0) AS total_vendido
        FROM detalle_pedidos dp2
        INNER JOIN productos p2 ON dp2.producto_id = p2.id
        WHERE p2.categoria_id = p.categoria_id
        GROUP BY p2.id
    ) AS ventas_por_categoria
)
ORDER BY c.nombre, total_vendido DESC;

-- Explicaci√≥n:
-- COALESCE: maneja productos sin ventas
-- WHERE COALESCE(...) >: compara ventas del producto
-- Subconsulta correlacionada: calcula promedio de ventas por categor√≠a
-- p2.categoria_id = p.categoria_id: correlaci√≥n por categor√≠a
-- Resultado: productos con ventas superiores al promedio de su categor√≠a

-- Consulta 4: Ranking de productos dentro de cada categor√≠a
SELECT 
    p.nombre AS producto,
    p.precio,
    c.nombre AS categoria,
    COALESCE((SELECT SUM(dp.cantidad) FROM detalle_pedidos dp WHERE dp.producto_id = p.id), 0) AS total_vendido,
    RANK() OVER (PARTITION BY c.id ORDER BY COALESCE((SELECT SUM(dp.cantidad) FROM detalle_pedidos dp WHERE dp.producto_id = p.id), 0) DESC) AS ranking_categoria
FROM productos p
INNER JOIN categorias c ON p.categoria_id = c.id
ORDER BY c.nombre, ranking_categoria;

-- Explicaci√≥n:
-- RANK() OVER (PARTITION BY c.id ORDER BY ...): ranking por categor√≠a
-- PARTITION BY c.id: separa ranking por categor√≠a
-- ORDER BY COALESCE(...) DESC: ordena por ventas descendente
-- COALESCE: maneja productos sin ventas
-- Resultado: ranking de productos dentro de cada categor√≠a
```

### Ejercicio 2: Operador EXISTS
**Objetivo**: Practicar el operador EXISTS para verificar existencia.

**Instrucciones**:
1. Mostrar usuarios que han hecho pedidos
2. Identificar productos que nunca se han vendido
3. Encontrar categor√≠as que tienen productos vendidos
4. Mostrar usuarios que han comprado productos de electr√≥nicos

**Soluci√≥n paso a paso:**

```sql
-- Consulta 1: Usuarios que han hecho pedidos
SELECT 
    u.nombre AS usuario,
    u.email,
    u.fecha_registro,
    (SELECT COUNT(*) FROM pedidos p WHERE p.usuario_id = u.id) AS total_pedidos
FROM usuarios u
WHERE EXISTS (
    SELECT 1
    FROM pedidos p
    WHERE p.usuario_id = u.id
)
ORDER BY total_pedidos DESC;

-- Explicaci√≥n:
-- WHERE EXISTS: verifica existencia de pedidos
-- (SELECT 1 FROM pedidos p WHERE p.usuario_id = u.id): subconsulta de existencia
-- SELECT 1: no importa qu√© se seleccione, solo la existencia
-- WHERE p.usuario_id = u.id: condici√≥n de correlaci√≥n
-- (SELECT COUNT(*) FROM pedidos p WHERE p.usuario_id = u.id): cuenta pedidos para mostrar

-- Consulta 2: Productos que nunca se han vendido
SELECT 
    p.nombre AS producto,
    p.precio,
    c.nombre AS categoria,
    p.stock
FROM productos p
INNER JOIN categorias c ON p.categoria_id = c.id
WHERE NOT EXISTS (
    SELECT 1
    FROM detalle_pedidos dp
    WHERE dp.producto_id = p.id
)
ORDER BY p.precio DESC;

-- Explicaci√≥n:
-- WHERE NOT EXISTS: verifica que NO existan ventas
-- (SELECT 1 FROM detalle_pedidos dp WHERE dp.producto_id = p.id): subconsulta de existencia
-- NOT EXISTS: niega la existencia
-- Resultado: productos que nunca se han vendido

-- Consulta 3: Categor√≠as que tienen productos vendidos
SELECT 
    c.nombre AS categoria,
    c.descripcion,
    (SELECT COUNT(DISTINCT p.id) FROM productos p INNER JOIN detalle_pedidos dp ON p.id = dp.producto_id WHERE p.categoria_id = c.id) AS productos_vendidos
FROM categorias c
WHERE EXISTS (
    SELECT 1
    FROM productos p
    INNER JOIN detalle_pedidos dp ON p.id = dp.producto_id
    WHERE p.categoria_id = c.id
)
ORDER BY productos_vendidos DESC;

-- Explicaci√≥n:
-- WHERE EXISTS: verifica existencia de productos vendidos
-- Subconsulta: busca productos de la categor√≠a que tengan ventas
-- INNER JOIN detalle_pedidos dp ON p.id = dp.producto_id: une con ventas
-- WHERE p.categoria_id = c.id: correlaci√≥n por categor√≠a
-- (SELECT COUNT(DISTINCT p.id) ...): cuenta productos vendidos para mostrar

-- Consulta 4: Usuarios que han comprado productos de electr√≥nicos
SELECT 
    u.nombre AS usuario,
    u.email,
    (SELECT COUNT(DISTINCT p.id) FROM pedidos p INNER JOIN detalle_pedidos dp ON p.id = dp.pedido_id INNER JOIN productos pr ON dp.producto_id = pr.id INNER JOIN categorias c ON pr.categoria_id = c.id WHERE p.usuario_id = u.id AND c.nombre = 'Electr√≥nicos') AS productos_electronicos_comprados
FROM usuarios u
WHERE EXISTS (
    SELECT 1
    FROM pedidos p
    INNER JOIN detalle_pedidos dp ON p.id = dp.pedido_id
    INNER JOIN productos pr ON dp.producto_id = pr.id
    INNER JOIN categorias c ON pr.categoria_id = c.id
    WHERE p.usuario_id = u.id
    AND c.nombre = 'Electr√≥nicos'
)
ORDER BY productos_electronicos_comprados DESC;

-- Explicaci√≥n:
-- WHERE EXISTS: verifica existencia de compras de electr√≥nicos
-- Subconsulta: busca pedidos del usuario con productos de electr√≥nicos
-- M√∫ltiples INNER JOINs: une pedidos, detalles, productos y categor√≠as
-- WHERE p.usuario_id = u.id AND c.nombre = 'Electr√≥nicos': condiciones de correlaci√≥n
-- (SELECT COUNT(DISTINCT p.id) ...): cuenta productos de electr√≥nicos comprados
```

### Ejercicio 3: Operadores IN, ANY, ALL
**Objetivo**: Practicar operadores IN, ANY, ALL para comparaciones m√∫ltiples.

**Instrucciones**:
1. Mostrar productos de categor√≠as populares
2. Encontrar productos m√°s caros que cualquier producto de ropa
3. Identificar productos m√°s caros que todos los productos de electr√≥nicos
4. Mostrar usuarios que han comprado productos de todas las categor√≠as

**Soluci√≥n paso a paso:**

```sql
-- Consulta 1: Productos de categor√≠as populares (m√°s de 2 productos)
SELECT 
    p.nombre AS producto,
    p.precio,
    c.nombre AS categoria,
    (SELECT COUNT(*) FROM productos p2 WHERE p2.categoria_id = p.categoria_id) AS productos_en_categoria
FROM productos p
INNER JOIN categorias c ON p.categoria_id = c.id
WHERE p.categoria_id IN (
    SELECT categoria_id
    FROM productos
    GROUP BY categoria_id
    HAVING COUNT(*) > 2
)
ORDER BY c.nombre, p.precio DESC;

-- Explicaci√≥n:
-- WHERE p.categoria_id IN: compara con lista de categor√≠as
-- (SELECT categoria_id FROM productos GROUP BY categoria_id HAVING COUNT(*) > 2): subconsulta
-- GROUP BY categoria_id: agrupa por categor√≠a
-- HAVING COUNT(*) > 2: filtra categor√≠as con m√°s de 2 productos
-- (SELECT COUNT(*) FROM productos p2 WHERE p2.categoria_id = p.categoria_id): cuenta productos para mostrar

-- Consulta 2: Productos con precio superior a cualquier producto de ropa
SELECT 
    p.nombre AS producto,
    p.precio,
    c.nombre AS categoria,
    (SELECT MIN(precio) FROM productos p2 INNER JOIN categorias c2 ON p2.categoria_id = c2.id WHERE c2.nombre = 'Ropa') AS precio_minimo_ropa
FROM productos p
INNER JOIN categorias c ON p.categoria_id = c.id
WHERE p.precio > ANY (
    SELECT precio
    FROM productos p2
    INNER JOIN categorias c2 ON p2.categoria_id = c2.id
    WHERE c2.nombre = 'Ropa'
)
ORDER BY p.precio DESC;

-- Explicaci√≥n:
-- WHERE p.precio > ANY: compara con cualquier precio de ropa
-- (SELECT precio FROM productos p2 INNER JOIN categorias c2 ON p2.categoria_id = c2.id WHERE c2.nombre = 'Ropa'): subconsulta
-- WHERE c2.nombre = 'Ropa': filtra solo productos de ropa
-- > ANY: mayor que cualquier precio de ropa
-- (SELECT MIN(precio) ...): muestra el precio m√≠nimo de ropa para referencia

-- Consulta 3: Productos con precio superior a todos los productos de electr√≥nicos
SELECT 
    p.nombre AS producto,
    p.precio,
    c.nombre AS categoria,
    (SELECT MAX(precio) FROM productos p2 INNER JOIN categorias c2 ON p2.categoria_id = c2.id WHERE c2.nombre = 'Electr√≥nicos') AS precio_maximo_electronicos
FROM productos p
INNER JOIN categorias c ON p.categoria_id = c.id
WHERE p.precio > ALL (
    SELECT precio
    FROM productos p2
    INNER JOIN categorias c2 ON p2.categoria_id = c2.id
    WHERE c2.nombre = 'Electr√≥nicos'
)
ORDER BY p.precio DESC;

-- Explicaci√≥n:
-- WHERE p.precio > ALL: compara con todos los precios de electr√≥nicos
-- (SELECT precio FROM productos p2 INNER JOIN categorias c2 ON p2.categoria_id = c2.id WHERE c2.nombre = 'Electr√≥nicos'): subconsulta
-- WHERE c2.nombre = 'Electr√≥nicos': filtra solo productos de electr√≥nicos
-- > ALL: mayor que todos los precios de electr√≥nicos
-- (SELECT MAX(precio) ...): muestra el precio m√°ximo de electr√≥nicos para referencia

-- Consulta 4: Usuarios que han comprado productos de todas las categor√≠as
SELECT 
    u.nombre AS usuario,
    u.email,
    (SELECT COUNT(DISTINCT c.id) FROM pedidos p INNER JOIN detalle_pedidos dp ON p.id = dp.pedido_id INNER JOIN productos pr ON dp.producto_id = pr.id INNER JOIN categorias c ON pr.categoria_id = c.id WHERE p.usuario_id = u.id) AS categorias_compradas,
    (SELECT COUNT(*) FROM categorias) AS total_categorias
FROM usuarios u
WHERE NOT EXISTS (
    SELECT 1
    FROM categorias c
    WHERE NOT EXISTS (
        SELECT 1
        FROM pedidos p
        INNER JOIN detalle_pedidos dp ON p.id = dp.pedido_id
        INNER JOIN productos pr ON dp.producto_id = pr.id
        WHERE p.usuario_id = u.id
        AND pr.categoria_id = c.id
    )
)
ORDER BY categorias_compradas DESC;

-- Explicaci√≥n:
-- WHERE NOT EXISTS: verifica que NO exista categor√≠a sin compra
-- Subconsulta externa: busca categor√≠as
-- WHERE NOT EXISTS: verifica que NO exista compra de esa categor√≠a
-- Subconsulta interna: busca compras del usuario en esa categor√≠a
-- (SELECT COUNT(DISTINCT c.id) ...): cuenta categor√≠as compradas para mostrar
-- (SELECT COUNT(*) FROM categorias): cuenta total de categor√≠as para referencia
-- Resultado: usuarios que han comprado de todas las categor√≠as
```

---

## üìù Resumen de Conceptos Clave

### Subconsultas Correlacionadas:
- **Referencia externa**: Acceden a columnas de la consulta principal
- **Ejecuci√≥n m√∫ltiple**: Se ejecutan para cada fila externa
- **Dependencia**: Su resultado depende del contexto externo
- **Rendimiento**: Pueden ser m√°s lentas que subconsultas independientes

### Operador EXISTS:
- **Verificaci√≥n de existencia**: Comprueba si hay al menos una fila
- **Rendimiento**: Se detiene en la primera coincidencia
- **Legibilidad**: C√≥digo m√°s claro que COUNT() > 0
- **Eficiencia**: No necesita procesar todas las filas

### Operadores IN, ANY, ALL:
- **IN**: Compara con lista de valores (igual a alguno)
- **ANY**: Compara con cualquier valor de la lista
- **ALL**: Compara con todos los valores de la lista
- **Flexibilidad**: Permiten comparaciones complejas

### Cu√°ndo Usar Cada T√©cnica:
- **Subconsultas correlacionadas**: Para an√°lisis por grupos
- **EXISTS**: Para verificar existencia de relaciones
- **IN**: Para filtrar por lista de valores
- **ANY/ALL**: Para comparaciones con m√∫ltiples valores

### Mejores Pr√°cticas:
1. **Optimiza subconsultas correlacionadas** con √≠ndices apropiados
2. **Usa EXISTS** en lugar de COUNT() > 0 para mejor rendimiento
3. **Considera el rendimiento** de subconsultas complejas
4. **Documenta la l√≥gica** de subconsultas anidadas
5. **Prueba con datos peque√±os** antes de ejecutar en producci√≥n

---

## üöÄ Pr√≥ximos Pasos

En la siguiente clase aprender√°s:
- Funciones de ventana (ROW_NUMBER, RANK, DENSE_RANK)
- Funciones LAG y LEAD para an√°lisis temporal
- Particionamiento y ordenamiento en ventanas
- T√©cnicas avanzadas de an√°lisis de datos

---

## üí° Consejos para el √âxito

1. **Entiende la correlaci√≥n**: Las subconsultas correlacionadas dependen del contexto externo
2. **Usa EXISTS eficientemente**: Es m√°s r√°pido que COUNT() > 0
3. **Prueba operadores**: IN, ANY, ALL tienen comportamientos diferentes
4. **Optimiza el rendimiento**: Las subconsultas complejas pueden ser lentas
5. **Documenta la l√≥gica**: Las subconsultas anidadas pueden ser confusas

---

## üß≠ Navegaci√≥n

**‚Üê Anterior**: [Clase 3: Subconsultas B√°sicas](clase_3_subconsultas_basicas.md)  
**Siguiente ‚Üí**: [Clase 5: Funciones de Ventana](clase_5_funciones_ventana.md)

---

*¬°Excelente trabajo! Ahora dominas las subconsultas avanzadas en SQL. üöÄ*
